// This file was generated by counterfeiter
package fakeroutingtable

import (
	"sync"

	"code.cloudfoundry.org/bbs/models"
	"code.cloudfoundry.org/route-emitter/routing_table"
)

type FakeNATSRoutingTable struct {
	RouteCountStub        func() int
	routeCountMutex       sync.RWMutex
	routeCountArgsForCall []struct{}
	routeCountReturns     struct {
		result1 int
	}
	routeCountReturnsOnCall map[int]struct {
		result1 int
	}
	SwapStub        func(newTable routing_table.NATSRoutingTable, domains models.DomainSet) routing_table.MessagesToEmit
	swapMutex       sync.RWMutex
	swapArgsForCall []struct {
		newTable routing_table.NATSRoutingTable
		domains  models.DomainSet
	}
	swapReturns struct {
		result1 routing_table.MessagesToEmit
	}
	swapReturnsOnCall map[int]struct {
		result1 routing_table.MessagesToEmit
	}
	SetRoutesStub        func(key routing_table.RoutingKey, routes []routing_table.Route, modTag *models.ModificationTag) routing_table.MessagesToEmit
	setRoutesMutex       sync.RWMutex
	setRoutesArgsForCall []struct {
		key    routing_table.RoutingKey
		routes []routing_table.Route
		modTag *models.ModificationTag
	}
	setRoutesReturns struct {
		result1 routing_table.MessagesToEmit
	}
	setRoutesReturnsOnCall map[int]struct {
		result1 routing_table.MessagesToEmit
	}
	GetRoutesStub        func(key routing_table.RoutingKey) []routing_table.Route
	getRoutesMutex       sync.RWMutex
	getRoutesArgsForCall []struct {
		key routing_table.RoutingKey
	}
	getRoutesReturns struct {
		result1 []routing_table.Route
	}
	getRoutesReturnsOnCall map[int]struct {
		result1 []routing_table.Route
	}
	RemoveRoutesStub        func(key routing_table.RoutingKey, modTag *models.ModificationTag) routing_table.MessagesToEmit
	removeRoutesMutex       sync.RWMutex
	removeRoutesArgsForCall []struct {
		key    routing_table.RoutingKey
		modTag *models.ModificationTag
	}
	removeRoutesReturns struct {
		result1 routing_table.MessagesToEmit
	}
	removeRoutesReturnsOnCall map[int]struct {
		result1 routing_table.MessagesToEmit
	}
	AddEndpointStub        func(key routing_table.RoutingKey, endpoint routing_table.Endpoint) routing_table.MessagesToEmit
	addEndpointMutex       sync.RWMutex
	addEndpointArgsForCall []struct {
		key      routing_table.RoutingKey
		endpoint routing_table.Endpoint
	}
	addEndpointReturns struct {
		result1 routing_table.MessagesToEmit
	}
	addEndpointReturnsOnCall map[int]struct {
		result1 routing_table.MessagesToEmit
	}
	RemoveEndpointStub        func(key routing_table.RoutingKey, endpoint routing_table.Endpoint) routing_table.MessagesToEmit
	removeEndpointMutex       sync.RWMutex
	removeEndpointArgsForCall []struct {
		key      routing_table.RoutingKey
		endpoint routing_table.Endpoint
	}
	removeEndpointReturns struct {
		result1 routing_table.MessagesToEmit
	}
	removeEndpointReturnsOnCall map[int]struct {
		result1 routing_table.MessagesToEmit
	}
	EndpointsForIndexStub        func(key routing_table.RoutingKey, index int32) []routing_table.Endpoint
	endpointsForIndexMutex       sync.RWMutex
	endpointsForIndexArgsForCall []struct {
		key   routing_table.RoutingKey
		index int32
	}
	endpointsForIndexReturns struct {
		result1 []routing_table.Endpoint
	}
	endpointsForIndexReturnsOnCall map[int]struct {
		result1 []routing_table.Endpoint
	}
	MessagesToEmitStub        func() routing_table.MessagesToEmit
	messagesToEmitMutex       sync.RWMutex
	messagesToEmitArgsForCall []struct{}
	messagesToEmitReturns     struct {
		result1 routing_table.MessagesToEmit
	}
	messagesToEmitReturnsOnCall map[int]struct {
		result1 routing_table.MessagesToEmit
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeNATSRoutingTable) RouteCount() int {
	fake.routeCountMutex.Lock()
	ret, specificReturn := fake.routeCountReturnsOnCall[len(fake.routeCountArgsForCall)]
	fake.routeCountArgsForCall = append(fake.routeCountArgsForCall, struct{}{})
	fake.recordInvocation("RouteCount", []interface{}{})
	fake.routeCountMutex.Unlock()
	if fake.RouteCountStub != nil {
		return fake.RouteCountStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.routeCountReturns.result1
}

func (fake *FakeNATSRoutingTable) RouteCountCallCount() int {
	fake.routeCountMutex.RLock()
	defer fake.routeCountMutex.RUnlock()
	return len(fake.routeCountArgsForCall)
}

func (fake *FakeNATSRoutingTable) RouteCountReturns(result1 int) {
	fake.RouteCountStub = nil
	fake.routeCountReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeNATSRoutingTable) RouteCountReturnsOnCall(i int, result1 int) {
	fake.RouteCountStub = nil
	if fake.routeCountReturnsOnCall == nil {
		fake.routeCountReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.routeCountReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeNATSRoutingTable) Swap(newTable routing_table.NATSRoutingTable, domains models.DomainSet) routing_table.MessagesToEmit {
	fake.swapMutex.Lock()
	ret, specificReturn := fake.swapReturnsOnCall[len(fake.swapArgsForCall)]
	fake.swapArgsForCall = append(fake.swapArgsForCall, struct {
		newTable routing_table.NATSRoutingTable
		domains  models.DomainSet
	}{newTable, domains})
	fake.recordInvocation("Swap", []interface{}{newTable, domains})
	fake.swapMutex.Unlock()
	if fake.SwapStub != nil {
		return fake.SwapStub(newTable, domains)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.swapReturns.result1
}

func (fake *FakeNATSRoutingTable) SwapCallCount() int {
	fake.swapMutex.RLock()
	defer fake.swapMutex.RUnlock()
	return len(fake.swapArgsForCall)
}

func (fake *FakeNATSRoutingTable) SwapArgsForCall(i int) (routing_table.NATSRoutingTable, models.DomainSet) {
	fake.swapMutex.RLock()
	defer fake.swapMutex.RUnlock()
	return fake.swapArgsForCall[i].newTable, fake.swapArgsForCall[i].domains
}

func (fake *FakeNATSRoutingTable) SwapReturns(result1 routing_table.MessagesToEmit) {
	fake.SwapStub = nil
	fake.swapReturns = struct {
		result1 routing_table.MessagesToEmit
	}{result1}
}

func (fake *FakeNATSRoutingTable) SwapReturnsOnCall(i int, result1 routing_table.MessagesToEmit) {
	fake.SwapStub = nil
	if fake.swapReturnsOnCall == nil {
		fake.swapReturnsOnCall = make(map[int]struct {
			result1 routing_table.MessagesToEmit
		})
	}
	fake.swapReturnsOnCall[i] = struct {
		result1 routing_table.MessagesToEmit
	}{result1}
}

func (fake *FakeNATSRoutingTable) SetRoutes(key routing_table.RoutingKey, routes []routing_table.Route, modTag *models.ModificationTag) routing_table.MessagesToEmit {
	var routesCopy []routing_table.Route
	if routes != nil {
		routesCopy = make([]routing_table.Route, len(routes))
		copy(routesCopy, routes)
	}
	fake.setRoutesMutex.Lock()
	ret, specificReturn := fake.setRoutesReturnsOnCall[len(fake.setRoutesArgsForCall)]
	fake.setRoutesArgsForCall = append(fake.setRoutesArgsForCall, struct {
		key    routing_table.RoutingKey
		routes []routing_table.Route
		modTag *models.ModificationTag
	}{key, routesCopy, modTag})
	fake.recordInvocation("SetRoutes", []interface{}{key, routesCopy, modTag})
	fake.setRoutesMutex.Unlock()
	if fake.SetRoutesStub != nil {
		return fake.SetRoutesStub(key, routes, modTag)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setRoutesReturns.result1
}

func (fake *FakeNATSRoutingTable) SetRoutesCallCount() int {
	fake.setRoutesMutex.RLock()
	defer fake.setRoutesMutex.RUnlock()
	return len(fake.setRoutesArgsForCall)
}

func (fake *FakeNATSRoutingTable) SetRoutesArgsForCall(i int) (routing_table.RoutingKey, []routing_table.Route, *models.ModificationTag) {
	fake.setRoutesMutex.RLock()
	defer fake.setRoutesMutex.RUnlock()
	return fake.setRoutesArgsForCall[i].key, fake.setRoutesArgsForCall[i].routes, fake.setRoutesArgsForCall[i].modTag
}

func (fake *FakeNATSRoutingTable) SetRoutesReturns(result1 routing_table.MessagesToEmit) {
	fake.SetRoutesStub = nil
	fake.setRoutesReturns = struct {
		result1 routing_table.MessagesToEmit
	}{result1}
}

func (fake *FakeNATSRoutingTable) SetRoutesReturnsOnCall(i int, result1 routing_table.MessagesToEmit) {
	fake.SetRoutesStub = nil
	if fake.setRoutesReturnsOnCall == nil {
		fake.setRoutesReturnsOnCall = make(map[int]struct {
			result1 routing_table.MessagesToEmit
		})
	}
	fake.setRoutesReturnsOnCall[i] = struct {
		result1 routing_table.MessagesToEmit
	}{result1}
}

func (fake *FakeNATSRoutingTable) GetRoutes(key routing_table.RoutingKey) []routing_table.Route {
	fake.getRoutesMutex.Lock()
	ret, specificReturn := fake.getRoutesReturnsOnCall[len(fake.getRoutesArgsForCall)]
	fake.getRoutesArgsForCall = append(fake.getRoutesArgsForCall, struct {
		key routing_table.RoutingKey
	}{key})
	fake.recordInvocation("GetRoutes", []interface{}{key})
	fake.getRoutesMutex.Unlock()
	if fake.GetRoutesStub != nil {
		return fake.GetRoutesStub(key)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getRoutesReturns.result1
}

func (fake *FakeNATSRoutingTable) GetRoutesCallCount() int {
	fake.getRoutesMutex.RLock()
	defer fake.getRoutesMutex.RUnlock()
	return len(fake.getRoutesArgsForCall)
}

func (fake *FakeNATSRoutingTable) GetRoutesArgsForCall(i int) routing_table.RoutingKey {
	fake.getRoutesMutex.RLock()
	defer fake.getRoutesMutex.RUnlock()
	return fake.getRoutesArgsForCall[i].key
}

func (fake *FakeNATSRoutingTable) GetRoutesReturns(result1 []routing_table.Route) {
	fake.GetRoutesStub = nil
	fake.getRoutesReturns = struct {
		result1 []routing_table.Route
	}{result1}
}

func (fake *FakeNATSRoutingTable) GetRoutesReturnsOnCall(i int, result1 []routing_table.Route) {
	fake.GetRoutesStub = nil
	if fake.getRoutesReturnsOnCall == nil {
		fake.getRoutesReturnsOnCall = make(map[int]struct {
			result1 []routing_table.Route
		})
	}
	fake.getRoutesReturnsOnCall[i] = struct {
		result1 []routing_table.Route
	}{result1}
}

func (fake *FakeNATSRoutingTable) RemoveRoutes(key routing_table.RoutingKey, modTag *models.ModificationTag) routing_table.MessagesToEmit {
	fake.removeRoutesMutex.Lock()
	ret, specificReturn := fake.removeRoutesReturnsOnCall[len(fake.removeRoutesArgsForCall)]
	fake.removeRoutesArgsForCall = append(fake.removeRoutesArgsForCall, struct {
		key    routing_table.RoutingKey
		modTag *models.ModificationTag
	}{key, modTag})
	fake.recordInvocation("RemoveRoutes", []interface{}{key, modTag})
	fake.removeRoutesMutex.Unlock()
	if fake.RemoveRoutesStub != nil {
		return fake.RemoveRoutesStub(key, modTag)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removeRoutesReturns.result1
}

func (fake *FakeNATSRoutingTable) RemoveRoutesCallCount() int {
	fake.removeRoutesMutex.RLock()
	defer fake.removeRoutesMutex.RUnlock()
	return len(fake.removeRoutesArgsForCall)
}

func (fake *FakeNATSRoutingTable) RemoveRoutesArgsForCall(i int) (routing_table.RoutingKey, *models.ModificationTag) {
	fake.removeRoutesMutex.RLock()
	defer fake.removeRoutesMutex.RUnlock()
	return fake.removeRoutesArgsForCall[i].key, fake.removeRoutesArgsForCall[i].modTag
}

func (fake *FakeNATSRoutingTable) RemoveRoutesReturns(result1 routing_table.MessagesToEmit) {
	fake.RemoveRoutesStub = nil
	fake.removeRoutesReturns = struct {
		result1 routing_table.MessagesToEmit
	}{result1}
}

func (fake *FakeNATSRoutingTable) RemoveRoutesReturnsOnCall(i int, result1 routing_table.MessagesToEmit) {
	fake.RemoveRoutesStub = nil
	if fake.removeRoutesReturnsOnCall == nil {
		fake.removeRoutesReturnsOnCall = make(map[int]struct {
			result1 routing_table.MessagesToEmit
		})
	}
	fake.removeRoutesReturnsOnCall[i] = struct {
		result1 routing_table.MessagesToEmit
	}{result1}
}

func (fake *FakeNATSRoutingTable) AddEndpoint(key routing_table.RoutingKey, endpoint routing_table.Endpoint) routing_table.MessagesToEmit {
	fake.addEndpointMutex.Lock()
	ret, specificReturn := fake.addEndpointReturnsOnCall[len(fake.addEndpointArgsForCall)]
	fake.addEndpointArgsForCall = append(fake.addEndpointArgsForCall, struct {
		key      routing_table.RoutingKey
		endpoint routing_table.Endpoint
	}{key, endpoint})
	fake.recordInvocation("AddEndpoint", []interface{}{key, endpoint})
	fake.addEndpointMutex.Unlock()
	if fake.AddEndpointStub != nil {
		return fake.AddEndpointStub(key, endpoint)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.addEndpointReturns.result1
}

func (fake *FakeNATSRoutingTable) AddEndpointCallCount() int {
	fake.addEndpointMutex.RLock()
	defer fake.addEndpointMutex.RUnlock()
	return len(fake.addEndpointArgsForCall)
}

func (fake *FakeNATSRoutingTable) AddEndpointArgsForCall(i int) (routing_table.RoutingKey, routing_table.Endpoint) {
	fake.addEndpointMutex.RLock()
	defer fake.addEndpointMutex.RUnlock()
	return fake.addEndpointArgsForCall[i].key, fake.addEndpointArgsForCall[i].endpoint
}

func (fake *FakeNATSRoutingTable) AddEndpointReturns(result1 routing_table.MessagesToEmit) {
	fake.AddEndpointStub = nil
	fake.addEndpointReturns = struct {
		result1 routing_table.MessagesToEmit
	}{result1}
}

func (fake *FakeNATSRoutingTable) AddEndpointReturnsOnCall(i int, result1 routing_table.MessagesToEmit) {
	fake.AddEndpointStub = nil
	if fake.addEndpointReturnsOnCall == nil {
		fake.addEndpointReturnsOnCall = make(map[int]struct {
			result1 routing_table.MessagesToEmit
		})
	}
	fake.addEndpointReturnsOnCall[i] = struct {
		result1 routing_table.MessagesToEmit
	}{result1}
}

func (fake *FakeNATSRoutingTable) RemoveEndpoint(key routing_table.RoutingKey, endpoint routing_table.Endpoint) routing_table.MessagesToEmit {
	fake.removeEndpointMutex.Lock()
	ret, specificReturn := fake.removeEndpointReturnsOnCall[len(fake.removeEndpointArgsForCall)]
	fake.removeEndpointArgsForCall = append(fake.removeEndpointArgsForCall, struct {
		key      routing_table.RoutingKey
		endpoint routing_table.Endpoint
	}{key, endpoint})
	fake.recordInvocation("RemoveEndpoint", []interface{}{key, endpoint})
	fake.removeEndpointMutex.Unlock()
	if fake.RemoveEndpointStub != nil {
		return fake.RemoveEndpointStub(key, endpoint)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removeEndpointReturns.result1
}

func (fake *FakeNATSRoutingTable) RemoveEndpointCallCount() int {
	fake.removeEndpointMutex.RLock()
	defer fake.removeEndpointMutex.RUnlock()
	return len(fake.removeEndpointArgsForCall)
}

func (fake *FakeNATSRoutingTable) RemoveEndpointArgsForCall(i int) (routing_table.RoutingKey, routing_table.Endpoint) {
	fake.removeEndpointMutex.RLock()
	defer fake.removeEndpointMutex.RUnlock()
	return fake.removeEndpointArgsForCall[i].key, fake.removeEndpointArgsForCall[i].endpoint
}

func (fake *FakeNATSRoutingTable) RemoveEndpointReturns(result1 routing_table.MessagesToEmit) {
	fake.RemoveEndpointStub = nil
	fake.removeEndpointReturns = struct {
		result1 routing_table.MessagesToEmit
	}{result1}
}

func (fake *FakeNATSRoutingTable) RemoveEndpointReturnsOnCall(i int, result1 routing_table.MessagesToEmit) {
	fake.RemoveEndpointStub = nil
	if fake.removeEndpointReturnsOnCall == nil {
		fake.removeEndpointReturnsOnCall = make(map[int]struct {
			result1 routing_table.MessagesToEmit
		})
	}
	fake.removeEndpointReturnsOnCall[i] = struct {
		result1 routing_table.MessagesToEmit
	}{result1}
}

func (fake *FakeNATSRoutingTable) EndpointsForIndex(key routing_table.RoutingKey, index int32) []routing_table.Endpoint {
	fake.endpointsForIndexMutex.Lock()
	ret, specificReturn := fake.endpointsForIndexReturnsOnCall[len(fake.endpointsForIndexArgsForCall)]
	fake.endpointsForIndexArgsForCall = append(fake.endpointsForIndexArgsForCall, struct {
		key   routing_table.RoutingKey
		index int32
	}{key, index})
	fake.recordInvocation("EndpointsForIndex", []interface{}{key, index})
	fake.endpointsForIndexMutex.Unlock()
	if fake.EndpointsForIndexStub != nil {
		return fake.EndpointsForIndexStub(key, index)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.endpointsForIndexReturns.result1
}

func (fake *FakeNATSRoutingTable) EndpointsForIndexCallCount() int {
	fake.endpointsForIndexMutex.RLock()
	defer fake.endpointsForIndexMutex.RUnlock()
	return len(fake.endpointsForIndexArgsForCall)
}

func (fake *FakeNATSRoutingTable) EndpointsForIndexArgsForCall(i int) (routing_table.RoutingKey, int32) {
	fake.endpointsForIndexMutex.RLock()
	defer fake.endpointsForIndexMutex.RUnlock()
	return fake.endpointsForIndexArgsForCall[i].key, fake.endpointsForIndexArgsForCall[i].index
}

func (fake *FakeNATSRoutingTable) EndpointsForIndexReturns(result1 []routing_table.Endpoint) {
	fake.EndpointsForIndexStub = nil
	fake.endpointsForIndexReturns = struct {
		result1 []routing_table.Endpoint
	}{result1}
}

func (fake *FakeNATSRoutingTable) EndpointsForIndexReturnsOnCall(i int, result1 []routing_table.Endpoint) {
	fake.EndpointsForIndexStub = nil
	if fake.endpointsForIndexReturnsOnCall == nil {
		fake.endpointsForIndexReturnsOnCall = make(map[int]struct {
			result1 []routing_table.Endpoint
		})
	}
	fake.endpointsForIndexReturnsOnCall[i] = struct {
		result1 []routing_table.Endpoint
	}{result1}
}

func (fake *FakeNATSRoutingTable) MessagesToEmit() routing_table.MessagesToEmit {
	fake.messagesToEmitMutex.Lock()
	ret, specificReturn := fake.messagesToEmitReturnsOnCall[len(fake.messagesToEmitArgsForCall)]
	fake.messagesToEmitArgsForCall = append(fake.messagesToEmitArgsForCall, struct{}{})
	fake.recordInvocation("MessagesToEmit", []interface{}{})
	fake.messagesToEmitMutex.Unlock()
	if fake.MessagesToEmitStub != nil {
		return fake.MessagesToEmitStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.messagesToEmitReturns.result1
}

func (fake *FakeNATSRoutingTable) MessagesToEmitCallCount() int {
	fake.messagesToEmitMutex.RLock()
	defer fake.messagesToEmitMutex.RUnlock()
	return len(fake.messagesToEmitArgsForCall)
}

func (fake *FakeNATSRoutingTable) MessagesToEmitReturns(result1 routing_table.MessagesToEmit) {
	fake.MessagesToEmitStub = nil
	fake.messagesToEmitReturns = struct {
		result1 routing_table.MessagesToEmit
	}{result1}
}

func (fake *FakeNATSRoutingTable) MessagesToEmitReturnsOnCall(i int, result1 routing_table.MessagesToEmit) {
	fake.MessagesToEmitStub = nil
	if fake.messagesToEmitReturnsOnCall == nil {
		fake.messagesToEmitReturnsOnCall = make(map[int]struct {
			result1 routing_table.MessagesToEmit
		})
	}
	fake.messagesToEmitReturnsOnCall[i] = struct {
		result1 routing_table.MessagesToEmit
	}{result1}
}

func (fake *FakeNATSRoutingTable) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.routeCountMutex.RLock()
	defer fake.routeCountMutex.RUnlock()
	fake.swapMutex.RLock()
	defer fake.swapMutex.RUnlock()
	fake.setRoutesMutex.RLock()
	defer fake.setRoutesMutex.RUnlock()
	fake.getRoutesMutex.RLock()
	defer fake.getRoutesMutex.RUnlock()
	fake.removeRoutesMutex.RLock()
	defer fake.removeRoutesMutex.RUnlock()
	fake.addEndpointMutex.RLock()
	defer fake.addEndpointMutex.RUnlock()
	fake.removeEndpointMutex.RLock()
	defer fake.removeEndpointMutex.RUnlock()
	fake.endpointsForIndexMutex.RLock()
	defer fake.endpointsForIndexMutex.RUnlock()
	fake.messagesToEmitMutex.RLock()
	defer fake.messagesToEmitMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeNATSRoutingTable) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ routing_table.NATSRoutingTable = new(FakeNATSRoutingTable)
